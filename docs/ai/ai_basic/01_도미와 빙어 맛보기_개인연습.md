# 시나리오

- 마켓에서 생선을 판매한다.
- 물류센터에서 신선한 생선을 직배송
- 물류센터 직원이 생선을 분류해야 된다.
- 이를 위해 분류기를 구현하고자 한다.


### 생선을 어떤 기준으로 분류할 수 있을까?
- 생선 분류를 위해 특징을 알아야 한다.
- 도미는 길이가 30cm이상이라고 한다.


```python
# 생선의 길이가 30cm이상이면 도미로 분류하는 프로그램
```


```python
fish_length = int(input('생선 길이:'))
if fish_length >=30:
    print('도미')
```

### 위 프로그램의 문제점?
- 생선 길이가 30cm이상이라고 무조건 도미인가?

### 이러한 문제를 해결하기 위해 생각해보기
- 일반적인 프로그램은 정해준 기준대로 동작
- 머신러닝은 학습을 통해 기준을 만들어 동작
- 여러 개의 도미 생선의 정보를 학습시켜 도미를 구분할 기준을 선정하도록 함
- 학습을 위한 데이터를 수집
    - 직접 도미들의 길이와 무게를 측정
    - 도미와 구분을 위해 빙어를 추가로 측정
    - 측정한 데이터를 준비하여 진행
    
#### 학습을 위한 데이터가 필요하며 이를 위해 데이터 수집을 해야 함


```python
# 수집된 데이터
bream_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0, 31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0, 35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0]
bream_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0, 500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0, 700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0]
```

#### 시각화하기
- 데이터를 파악하기 위해 그래프를 활용할 수 있음
- matplotlib 라이브러리 활용
- 산점도(scatter)그래프를 그려본다.


```python
# 일반적으로 plt라는 별칭을 사용
import matplotlib.pyplot as plt

# 산점도 그래프에 데이터 설정
plt.scatter(bream_length, bream_weight)

# X축의 이름
plt.xlabel('lenght')

# Y축의 이름
plt.ylabel('weight')

# 그래프 그리기
plt.show()
```


    
![png](assets/images/1week/01/01_도미와 빙어 맛보기_개인연습_9_0.png)
    


- 위 그래프를 이용하여 알 수 있는 것은?
    - 생선의 길이가 길면 대체로 무게가 많이 나감
    - 위와 같은 형태를 선형(linear)적이다라고 말함


```python
smelt_length = [9.8, 10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]
smelt_weight = [6.7, 7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9]
```


```python
# 일반적으로 plt라는 별칭을 사용
import matplotlib.pyplot as plt

# 산점도 그래프에 빙어 데이터 설정
plt.scatter(smelt_length, smelt_weight)

# X축의 이름
plt.xlabel('lenght')

# Y축의 이름
plt.ylabel('weight')

# 그래프 그리기
plt.show()
```


    
![png](01_%EB%8F%84%EB%AF%B8%EC%99%80%20%EB%B9%99%EC%96%B4%20%EB%A7%9B%EB%B3%B4%EA%B8%B0_%EA%B0%9C%EC%9D%B8%EC%97%B0%EC%8A%B5_files/01_%EB%8F%84%EB%AF%B8%EC%99%80%20%EB%B9%99%EC%96%B4%20%EB%A7%9B%EB%B3%B4%EA%B8%B0_%EA%B0%9C%EC%9D%B8%EC%97%B0%EC%8A%B5_9_0.png)
    


- 위 그래프로 알 수 있는 것은?
    - 빙어도 길이에 따라 무게가 달라진다.
    - 도미에 비하면 그 차이가 미미하다.


```python
# 일반적으로 plt라는 별칭을 사용
import matplotlib.pyplot as plt

# 산점도 그래프에 도미 데이터 설정
plt.scatter(bream_length, bream_weight)

# 산점도 그래프에 빙어 데이터 설정
plt.scatter(smelt_length, smelt_weight)

# X축의 이름
plt.xlabel('lenght')

# Y축의 이름
plt.ylabel('weight')

# 그래프 그리기
plt.show()
```


    
![png](01_%EB%8F%84%EB%AF%B8%EC%99%80%20%EB%B9%99%EC%96%B4%20%EB%A7%9B%EB%B3%B4%EA%B8%B0_%EA%B0%9C%EC%9D%B8%EC%97%B0%EC%8A%B5_files/01_%EB%8F%84%EB%AF%B8%EC%99%80%20%EB%B9%99%EC%96%B4%20%EB%A7%9B%EB%B3%B4%EA%B8%B0_%EA%B0%9C%EC%9D%B8%EC%97%B0%EC%8A%B5_11_0.png)
    


- 위 그래프로 알 수 있는 것은?
- 빙어는 길이가 늘어나도 무게가 많이 늘어나지 않음
    (무게가 길이에 영향을 덜 받는 특성)

### 첫 번째 머신러닝 맛보기
- scikit-learn(사이킷런) 패키지 활용
- 사이킷런 패키지의 알고리즘들은 특성들을 2차원 형태로 만들어야 함
- kNN(k-Nearest Neighbors) : k-최근접 이웃 알고리즘으로 분류


```python
# 도미와 빙어 데이터 합치기
length = bream_length + smelt_length
weight = bream_weight + smelt_weight

fish_data = [[l,w] for l,w in zip(length,weight)]

print(fish_data)
```

    [[25.4, 242.0], [26.3, 290.0], [26.5, 340.0], [29.0, 363.0], [29.0, 430.0], [29.7, 450.0], [29.7, 500.0], [30.0, 390.0], [30.0, 450.0], [30.7, 500.0], [31.0, 475.0], [31.0, 500.0], [31.5, 500.0], [32.0, 340.0], [32.0, 600.0], [32.0, 600.0], [33.0, 700.0], [33.0, 700.0], [33.5, 610.0], [33.5, 650.0], [34.0, 575.0], [34.0, 685.0], [34.5, 620.0], [35.0, 680.0], [35.0, 700.0], [35.0, 725.0], [35.0, 720.0], [36.0, 714.0], [36.0, 850.0], [37.0, 1000.0], [38.5, 920.0], [38.5, 955.0], [39.5, 925.0], [41.0, 975.0], [41.0, 950.0], [9.8, 6.7], [10.5, 7.5], [10.6, 7.0], [11.0, 9.7], [11.2, 9.8], [11.3, 8.7], [11.8, 10.0], [11.8, 9.9], [12.0, 9.8], [12.2, 12.2], [12.4, 13.4], [13.0, 12.2], [14.3, 19.7], [15.0, 19.9]]
    


```python
# 각 길이와 무게에 따라 도미와 빙어를 분류한 정답을 생성
fish_target = [1]*35 + [0] *14
print(fish_target)
```

    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    


```python
# 학습(훈련)하기
# kNN 모델 import
from sklearn.neighbors import KNeighborsClassifier

# 모델 인스턴스 생성
kn = KNeighborsClassifier()

# 학습
kn.fit(fish_data,fish_target)
```




<style>#sk-container-id-1 {color: black;background-color: white;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-1" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>KNeighborsClassifier()</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-1" type="checkbox" checked><label for="sk-estimator-id-1" class="sk-toggleable__label sk-toggleable__label-arrow">KNeighborsClassifier</label><div class="sk-toggleable__content"><pre>KNeighborsClassifier()</pre></div></div></div></div></div>




```python
# 모델 평가(0 ~ 1 사이의 값을 반환함)
# 정확도(accuracy)
kn.score(fish_data,fish_target)
```




    1.0




```python
plt.scatter(bream_length, bream_weight)
plt.scatter(smelt_length, smelt_weight)

# 길이 35, 무게 530 마커 지정
plt.scatter(35, 530)

plt.xlabel('length')
plt.ylabel('weight')
plt.show()
```


    
![png](01_%EB%8F%84%EB%AF%B8%EC%99%80%20%EB%B9%99%EC%96%B4%20%EB%A7%9B%EB%B3%B4%EA%B8%B0_%EA%B0%9C%EC%9D%B8%EC%97%B0%EC%8A%B5_files/01_%EB%8F%84%EB%AF%B8%EC%99%80%20%EB%B9%99%EC%96%B4%20%EB%A7%9B%EB%B3%B4%EA%B8%B0_%EA%B0%9C%EC%9D%B8%EC%97%B0%EC%8A%B5_18_0.png)
    



```python
kn._fit_X # 모델이 저장하고 있는 데이터
```




    array([[  25.4,  242. ],
           [  26.3,  290. ],
           [  26.5,  340. ],
           [  29. ,  363. ],
           [  29. ,  430. ],
           [  29.7,  450. ],
           [  29.7,  500. ],
           [  30. ,  390. ],
           [  30. ,  450. ],
           [  30.7,  500. ],
           [  31. ,  475. ],
           [  31. ,  500. ],
           [  31.5,  500. ],
           [  32. ,  340. ],
           [  32. ,  600. ],
           [  32. ,  600. ],
           [  33. ,  700. ],
           [  33. ,  700. ],
           [  33.5,  610. ],
           [  33.5,  650. ],
           [  34. ,  575. ],
           [  34. ,  685. ],
           [  34.5,  620. ],
           [  35. ,  680. ],
           [  35. ,  700. ],
           [  35. ,  725. ],
           [  35. ,  720. ],
           [  36. ,  714. ],
           [  36. ,  850. ],
           [  37. , 1000. ],
           [  38.5,  920. ],
           [  38.5,  955. ],
           [  39.5,  925. ],
           [  41. ,  975. ],
           [  41. ,  950. ],
           [   9.8,    6.7],
           [  10.5,    7.5],
           [  10.6,    7. ],
           [  11. ,    9.7],
           [  11.2,    9.8],
           [  11.3,    8.7],
           [  11.8,   10. ],
           [  11.8,    9.9],
           [  12. ,    9.8],
           [  12.2,   12.2],
           [  12.4,   13.4],
           [  13. ,   12.2],
           [  14.3,   19.7],
           [  15. ,   19.9]])




```python
kn._y # 모델이 가지고 있는 타겟 속성
```




    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0])




```python
# 49개의 이웃으로 분류하는 모델 인스턴스 생성
kn49 = KNeighborsClassifier(n_neighbors = 49)

# 학습
kn49.fit(fish_data, fish_target)

# 정확도 확인
kn49.score(fish_data, fish_target)
```




    0.7142857142857143




```python
print(kn.predict([[35,530]]))
print(kn.predict([[15,150]]))
print(kn.predict([[20,200]]))
```

    [1]
    [0]
    [1]
    


```python
print(kn49.predict([[35,530]]))
print(kn49.predict([[16,150]]))
print(kn49.predict([[20,200]]))
```

    [1]
    [1]
    [1]
    
